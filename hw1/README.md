#HW1
---



| Name | Student ID |
| :--- | :--- |
| Yusuf OruÃ§ | 150720036 |
| Alihan Kocaakman | 150720065 |

---
## ğŸ“¸ Photos

### ğŸ–¼ï¸ Temel GÃ¶rÃ¼ntÃ¼ler

| GÃ¶rÃ¼ntÃ¼ AÃ§Ä±klamasÄ± | SonuÃ§ GÃ¶rÃ¼ntÃ¼sÃ¼ |
| :--- | :---: |
| **Main Image** (Grayscaled 64x64) | ![mainimg](https://github.com/user-attachments/assets/e0193dc9-6db3-4b59-a843-df4d8afbf450) |
---
| **Negative Transformation** (255 - pixel) | ![negative image](https://github.com/user-attachments/assets/2b775156-d00a-499b-a7d5-e2b94603dade) |

### ğŸ“Š Thresholding KarÅŸÄ±laÅŸtÄ±rmasÄ±

| Threshold DeÄŸeri | GÃ¶rÃ¼ntÃ¼ |
| :--- | :---: |
| **Threshold = 70** | ![treshold70image](https://github.com/user-attachments/assets/c06dba60-e383-49ac-b21d-73defaecbdda) |
| **Threshold = 140** | ![treshold140image](https://github.com/user-attachments/assets/f08389af-9635-40b2-b1c2-4d4310243cf3) |
| **Threshold = 210** | ![treshold210image](https://github.com/user-attachments/assets/a01ea0db-d67f-4877-9ee8-204c70d960a4) |

### ğŸ“ˆ DiÄŸer DÃ¶nÃ¼ÅŸÃ¼mler

| DÃ¶nÃ¼ÅŸÃ¼m Tipi | GÃ¶rÃ¼ntÃ¼ |
| :--- | :---: |
| **Gamma Correction** ($\gamma = 3$) | ![gama3image](https://github.com/user-attachments/assets/fea14ba5-b10b-4303-bf72-08df09e99e12) |
| **Gamma Correction** ($\gamma = 1/3$) | ![gama0 33image](https://github.com/user-attachments/assets/50ef6186-c7e1-41a6-85a2-1986ac2e91d5) |
---
| **Piecewise Linear** | ![piecewise](https://github.com/user-attachments/assets/28fc7dc4-cef8-4fd5-b8bc-22fcc2d97c62) |

Photos

-main image grayscaled 64x64
![mainimg](https://github.com/user-attachments/assets/e0193dc9-6db3-4b59-a843-df4d8afbf450)
---
-negative image
<img width="64" height="64" alt="negatitveImage" src="https://github.com/user-attachments/assets/2b775156-d00a-499b-a7d5-e2b94603dade" />
---
-thresholding = 70
<img width="64" height="64" alt="treshold70image" src="https://github.com/user-attachments/assets/c06dba60-e383-49ac-b21d-73defaecbdda" />
---
-thresholding = 140
<img width="64" height="64" alt="treshold140image" src="https://github.com/user-attachments/assets/f08389af-9635-40b2-b1c2-4d4310243cf3" />
---
-thresholding = 210 
<img width="64" height="64" alt="treshold210image" src="https://github.com/user-attachments/assets/a01ea0db-d67f-4877-9ee8-204c70d960a4" />
---
-gama correction = 3
<img width="64" height="64" alt="gama3image" src="https://github.com/user-attachments/assets/fea14ba5-b10b-4303-bf72-08df09e99e12" />
---
-gama correction = 1/3
<img width="64" height="64" alt="gama0 33image" src="https://github.com/user-attachments/assets/50ef6186-c7e1-41a6-85a2-1986ac2e91d5" />
---
-piecewise
<img width="64" height="64" alt="piecewise" src="https://github.com/user-attachments/assets/28fc7dc4-cef8-4fd5-b8bc-22fcc2d97c62" />
---

---

-Code
---

```c

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include <stdint.h>
#include <math.h>
#include "image.h"

#define IMAGE_WIDTH     64
#define IMAGE_HEIGHT    64
#define IMAGE_SIZE      4096

volatile unsigned char gThresholdImage[IMAGE_SIZE];
volatile unsigned char gThresholdImage2[IMAGE_SIZE];
volatile unsigned char gThresholdImage3[IMAGE_SIZE];
volatile unsigned char gNegativeImage[IMAGE_SIZE];
volatile unsigned char gGammaImage_gamma3[IMAGE_SIZE];
volatile unsigned char gGammaImage_gamma1_3[IMAGE_SIZE];
volatile unsigned char gPiecewiseImage[IMAGE_SIZE];

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void neg_func(const unsigned char* pSrc, unsigned char* pDst, int size)
{
    for (int i = 0; i < size; i++)
    {

        pDst[i] = 255 - pSrc[i];
    }
}

void apply_thresholding(const unsigned char* pSrc, unsigned char* pDst, int size, unsigned char threshold)
{
    for (int i = 0; i < size; i++)
    {
        if (pSrc[i] > threshold)
        {
            pDst[i] = 255;
        }
        else
        {
            pDst[i] = 0;
        }
    }
}

void apply_gamma_correction(const unsigned char* pSrc, unsigned char* pDst, int size, float gamma)
{

    float exponent = 1.0f / gamma;

    for (int i = 0; i < size; i++)
    {

        float norm_pixel = (float)pSrc[i] / 255.0f;


        float new_norm_pixel = powf(norm_pixel, exponent);


        float new_pixel_val = new_norm_pixel * 255.0f;

        pDst[i] = (unsigned char)new_pixel_val;

    }
}

void apply_piecewise_linear(const unsigned char* pSrc, unsigned char* pDst, int size, unsigned char r1, unsigned char r2)
{
    // HatalÄ± girdiyi Ã¶nle (r1, r2'ye eÅŸit veya bÃ¼yÃ¼kse)
    if (r1 >= r2) {
        r1 = 0;
        r2 = 255;
    }

    // TamsayÄ± matematiÄŸi iÃ§in r2-r1 farkÄ±nÄ± al
    unsigned char delta_r = r2 - r1;

    // SÄ±fÄ±ra bÃ¶lme hatasÄ±nÄ± engelle (r1 == r2 durumu, yukarÄ±da yakalandÄ± ama yine de gÃ¼venli)
    if (delta_r == 0) {
        for (int i = 0; i < size; i++) {
             pDst[i] = (pSrc[i] <= r1) ? 0 : 255;
        }
        return; // Fonksiyondan Ã§Ä±k
    }


    for (int i = 0; i < size; i++)
    {
        unsigned char p = pSrc[i];

        if (p < r1)
        {
            pDst[i] = 0;
        }
        else if (p > r2)
        {
            pDst[i] = 255;
        }
        else
        {
            // === FLOAT YERÄ°NE TAMSAYI MATEMATÄ°ÄÄ° ===
            // (p - r1) * 255 / (r2 - r1)

            // 1. Ã–nce (p - r1) farkÄ±nÄ± bul (en fazla 255 olabilir)
            uint32_t temp = (uint32_t)(p - r1);

            // 2. 255 ile Ã§arp (en fazla 255 * 255 = 65025 olur, uint32_t gÃ¼vende)
            temp = temp * 255;


            temp = temp / (uint32_t)delta_r;


            pDst[i] = (unsigned char)temp;
        }
    }
}
int main(void)
{

	//neg_func(image, gNegativeImage, IMAGE_SIZE);
	//apply_thresholding(image, gThresholdImage, IMAGE_SIZE, 70);
	//apply_thresholding(image, gThresholdImage2, IMAGE_SIZE, 140);
	//apply_thresholding(image, gThresholdImage3, IMAGE_SIZE, 210);
	//apply_gamma_correction(image, gGammaImage_gamma3, IMAGE_SIZE, 3.0f);
	//apply_gamma_correction(image, gGammaImage_gamma1_3, IMAGE_SIZE, (1.0f/3.0f));
	//apply_piecewise_linear(image, gPiecewiseImage, IMAGE_SIZE, 70, 140);
	//const uint8_t *a = &image;

	for(;;);
}


```
