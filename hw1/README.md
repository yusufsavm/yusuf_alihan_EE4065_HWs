#HW1
---



| Name | Student ID |
| :--- | :--- |
| Yusuf Oru√ß | 150720036 |
| Alihan Kocaakman | 150720065 |

---
## Photos

### Main Image

| Image Type | Image |
| :--- | :---: |
| **Main Image** (Grayscaled 64x64) | ![mainimg](https://github.com/user-attachments/assets/e0193dc9-6db3-4b59-a843-df4d8afbf450) |

### Negative Transformation

| Image Type | Image |
| :--- | :---: |
| **Negative Transformation** | ![negative image](https://github.com/user-attachments/assets/2b775156-d00a-499b-a7d5-e2b94603dade) |

### Thresholding Transformation

| Image Type | Image |
| :--- | :---: |
| **Threshold = 70** | ![treshold70image](https://github.com/user-attachments/assets/c06dba60-e383-49ac-b21d-73defaecbdda) |
| **Threshold = 140** | ![treshold140image](https://github.com/user-attachments/assets/f08389af-9635-40b2-b1c2-4d4310243cf3) |
| **Threshold = 210** | ![treshold210image](https://github.com/user-attachments/assets/a01ea0db-d67f-4877-9ee8-204c70d960a4) |

### Gama Correction

| Image Type | Image |
| :--- | :---: |
| **Gamma Correction** ($\gamma = 3$) | ![gama3image](https://github.com/user-attachments/assets/fea14ba5-b10b-4303-bf72-08df09e99e12) |
| **Gamma Correction** ($\gamma = 1/3$) | ![gama0 33image](https://github.com/user-attachments/assets/50ef6186-c7e1-41a6-85a2-1986ac2e91d5) |

### Piecewise Transformation

| Image Type | Image |
| :--- | :---: |
| **Piecewise Linear** | ![piecewise](https://github.com/user-attachments/assets/28fc7dc4-cef8-4fd5-b8bc-22fcc2d97c62) |



-Code
---

```c

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include <stdint.h>
#include <math.h>
#include "image.h"

#define IMAGE_WIDTH     64
#define IMAGE_HEIGHT    64
#define IMAGE_SIZE      4096

volatile unsigned char gThresholdImage[IMAGE_SIZE];
volatile unsigned char gThresholdImage2[IMAGE_SIZE];
volatile unsigned char gThresholdImage3[IMAGE_SIZE];
volatile unsigned char gNegativeImage[IMAGE_SIZE];
volatile unsigned char gGammaImage_gamma3[IMAGE_SIZE];
volatile unsigned char gGammaImage_gamma1_3[IMAGE_SIZE];
volatile unsigned char gPiecewiseImage[IMAGE_SIZE];

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void neg_func(const unsigned char* pSrc, unsigned char* pDst, int size)
{
    for (int i = 0; i < size; i++)
    {

        pDst[i] = 255 - pSrc[i];
    }
}

void apply_thresholding(const unsigned char* pSrc, unsigned char* pDst, int size, unsigned char threshold)
{
    for (int i = 0; i < size; i++)
    {
        if (pSrc[i] > threshold)
        {
            pDst[i] = 255;
        }
        else
        {
            pDst[i] = 0;
        }
    }
}

void apply_gamma_correction(const unsigned char* pSrc, unsigned char* pDst, int size, float gamma)
{

    float exponent = 1.0f / gamma;

    for (int i = 0; i < size; i++)
    {

        float norm_pixel = (float)pSrc[i] / 255.0f;


        float new_norm_pixel = powf(norm_pixel, exponent);


        float new_pixel_val = new_norm_pixel * 255.0f;

        pDst[i] = (unsigned char)new_pixel_val;

    }
}

void apply_piecewise_linear(const unsigned char* pSrc, unsigned char* pDst, int size, unsigned char r1, unsigned char r2)
{
   
    if (r1 >= r2) {
        r1 = 0;
        r2 = 255;
    }

   
    unsigned char delta_r = r2 - r1;

    
    if (delta_r == 0) {
        for (int i = 0; i < size; i++) {
             pDst[i] = (pSrc[i] <= r1) ? 0 : 255;
        }
        return; 
    }


    for (int i = 0; i < size; i++)
    {
        unsigned char p = pSrc[i];

        if (p < r1)
        {
            pDst[i] = 0;
        }
        else if (p > r2)
        {
            pDst[i] = 255;
        }
        else
        {
           
            // (p - r1) * 255 / (r2 - r1)

           
            uint32_t temp = (uint32_t)(p - r1);

            
            temp = temp * 255;


            temp = temp / (uint32_t)delta_r;


            pDst[i] = (unsigned char)temp;
        }
    }
}
int main(void)
{

	//neg_func(image, gNegativeImage, IMAGE_SIZE);
	//apply_thresholding(image, gThresholdImage, IMAGE_SIZE, 70);
	//apply_thresholding(image, gThresholdImage2, IMAGE_SIZE, 140);
	//apply_thresholding(image, gThresholdImage3, IMAGE_SIZE, 210);
	//apply_gamma_correction(image, gGammaImage_gamma3, IMAGE_SIZE, 3.0f);
	//apply_gamma_correction(image, gGammaImage_gamma1_3, IMAGE_SIZE, (1.0f/3.0f));
	//apply_piecewise_linear(image, gPiecewiseImage, IMAGE_SIZE, 70, 140);
	//const uint8_t *a = &image;

	for(;;);
}


```
