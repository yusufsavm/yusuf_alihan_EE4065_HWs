Photos

-main image grayscaled 64x64
![mainimg](https://github.com/user-attachments/assets/e0193dc9-6db3-4b59-a843-df4d8afbf450)

-negative image
<img width="64" height="64" alt="negatitveImage" src="https://github.com/user-attachments/assets/2b775156-d00a-499b-a7d5-e2b94603dade" />

-thresholding = 70
<img width="64" height="64" alt="treshold70image" src="https://github.com/user-attachments/assets/c06dba60-e383-49ac-b21d-73defaecbdda" />

-thresholding = 140
<img width="64" height="64" alt="treshold140image" src="https://github.com/user-attachments/assets/f08389af-9635-40b2-b1c2-4d4310243cf3" />

-thresholding = 210 
<img width="64" height="64" alt="treshold210image" src="https://github.com/user-attachments/assets/a01ea0db-d67f-4877-9ee8-204c70d960a4" />

-gama correction = 3
<img width="64" height="64" alt="gama3image" src="https://github.com/user-attachments/assets/fea14ba5-b10b-4303-bf72-08df09e99e12" />

-gama correction = 1/3
<img width="64" height="64" alt="gama0 33image" src="https://github.com/user-attachments/assets/50ef6186-c7e1-41a6-85a2-1986ac2e91d5" />

-piecewise
<img width="64" height="64" alt="piecewise" src="https://github.com/user-attachments/assets/28fc7dc4-cef8-4fd5-b8bc-22fcc2d97c62" />

-
-
-
-
-
-
-



-Code



-
-
-
-
-



/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include <stdint.h>
#include <math.h>
#include "image.h"

#define IMAGE_WIDTH     64
#define IMAGE_HEIGHT    64
#define IMAGE_SIZE      4096

volatile unsigned char gThresholdImage[IMAGE_SIZE];
volatile unsigned char gThresholdImage2[IMAGE_SIZE];
volatile unsigned char gThresholdImage3[IMAGE_SIZE];
volatile unsigned char gNegativeImage[IMAGE_SIZE];
volatile unsigned char gGammaImage_gamma3[IMAGE_SIZE];
volatile unsigned char gGammaImage_gamma1_3[IMAGE_SIZE];
volatile unsigned char gPiecewiseImage[IMAGE_SIZE];

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void neg_func(const unsigned char* pSrc, unsigned char* pDst, int size)
{
    for (int i = 0; i < size; i++)
    {

        pDst[i] = 255 - pSrc[i];
    }
}

void apply_thresholding(const unsigned char* pSrc, unsigned char* pDst, int size, unsigned char threshold)
{
    for (int i = 0; i < size; i++)
    {
        if (pSrc[i] > threshold)
        {
            pDst[i] = 255;
        }
        else
        {
            pDst[i] = 0;
        }
    }
}

void apply_gamma_correction(const unsigned char* pSrc, unsigned char* pDst, int size, float gamma)
{

    float exponent = 1.0f / gamma;

    for (int i = 0; i < size; i++)
    {

        float norm_pixel = (float)pSrc[i] / 255.0f;


        float new_norm_pixel = powf(norm_pixel, exponent);


        float new_pixel_val = new_norm_pixel * 255.0f;

        pDst[i] = (unsigned char)new_pixel_val;

    }
}

void apply_piecewise_linear(const unsigned char* pSrc, unsigned char* pDst, int size, unsigned char r1, unsigned char r2)
{
    // Hatalı girdiyi önle (r1, r2'ye eşit veya büyükse)
    if (r1 >= r2) {
        r1 = 0;
        r2 = 255;
    }

    // Tamsayı matematiği için r2-r1 farkını al
    unsigned char delta_r = r2 - r1;

    // Sıfıra bölme hatasını engelle (r1 == r2 durumu, yukarıda yakalandı ama yine de güvenli)
    if (delta_r == 0) {
        for (int i = 0; i < size; i++) {
             pDst[i] = (pSrc[i] <= r1) ? 0 : 255;
        }
        return; // Fonksiyondan çık
    }


    for (int i = 0; i < size; i++)
    {
        unsigned char p = pSrc[i];

        if (p < r1)
        {
            pDst[i] = 0;
        }
        else if (p > r2)
        {
            pDst[i] = 255;
        }
        else
        {
            // === FLOAT YERİNE TAMSAYI MATEMATİĞİ ===
            // (p - r1) * 255 / (r2 - r1)

            // 1. Önce (p - r1) farkını bul (en fazla 255 olabilir)
            uint32_t temp = (uint32_t)(p - r1);

            // 2. 255 ile çarp (en fazla 255 * 255 = 65025 olur, uint32_t güvende)
            temp = temp * 255;


            temp = temp / (uint32_t)delta_r;


            pDst[i] = (unsigned char)temp;
        }
    }
}
int main(void)
{

	//neg_func(image, gNegativeImage, IMAGE_SIZE);
	//apply_thresholding(image, gThresholdImage, IMAGE_SIZE, 70);
	//apply_thresholding(image, gThresholdImage2, IMAGE_SIZE, 140);
	//apply_thresholding(image, gThresholdImage3, IMAGE_SIZE, 210);
	//apply_gamma_correction(image, gGammaImage_gamma3, IMAGE_SIZE, 3.0f);
	//apply_gamma_correction(image, gGammaImage_gamma1_3, IMAGE_SIZE, (1.0f/3.0f));
	//apply_piecewise_linear(image, gPiecewiseImage, IMAGE_SIZE, 70, 140);
	//const uint8_t *a = &image;

	for(;;);
}
